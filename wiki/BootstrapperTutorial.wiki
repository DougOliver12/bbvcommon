#summary Shows the basic usage of the Bootstrapper

= Introduction =
To get started with the bootstrapper you need the following three things:
 # Extension interface
 # Strategy
 # Bootstrapper setup
== Extension interface ==
The extension interface defines the extension points which are called by the bootstrapper. The custom extension interface must inherit from `IExtension` and can only declare methods which return `void` as extension points. A very basic extension interface could look like the following:

{{{
    public interface ICustomExtension : IExtension
    {
        void Start();
        void Stop();
    }
}}}
The extension interface above would indicate that the applications extension points are:
 * `Start`
 * `Stop`
That's basically it for the extension interface. Although we generally advice to build a base class which defines virtual members for the extension points. For example:

{{{
    public abstract class CustomExtensionBase : ICustomExtension
    {
        public string Name
        {
            get { return this.GetType().FullNameToString(); }
        }

        public virtual void Start() { }
        public virtual void Stop() { }
        public abstract string Describe();
    }
}}}
This allows inheritors to override only the extension points that they are interested in.

_Note: `IExtension` inherits from `IDescribable` which defines a name and a description. The name and the description are consumed by the reporting capability. The more expressive your names and descriptions are the more meaningful your report will be!_
== Strategy ==
The strategy defines the order of execution for extension points and behaviors. The custom strategy must inherit from `IStrategy`. For convenience there is a abstract base class `AbstractStrategy{TExtension}` which simplifies defining a custom strategy. A very basic strategy could look like the following:

{{{
    public class CustomStrategy : AbstractStrategy<ICustomExtension>
    {
        protected override void DefineRunSyntax(ISyntaxBuilder<ICustomExtension> builder)
        {
            builder.Execute(x => x.Start());
        }

        protected override void DefineShutdownSyntax(ISyntaxBuilder<ICustomExtension> builder)
        {
            builder.Execute(x => x.Stop());
        }
    }
}}}
The strategy above would configure the applications startup and shutdown phase to:
 * During startup call the extension point `Start` on all registered extensions
 * During shutdown call the extension point `Stop` on all registered extensions
Now let's look how the custom extension interface and the strategy get combined together in the bootstrapper.
== Bootstrapper setup ==
The bootstrapper setup is simply and straight forward. You can always follow the following steps:
 # Instantiate a new `DefaultBoostrapper<TExtension>`
 # Instantiate a new strategy
 # Initialize the bootstrapper with the strategy
 # Add the required extensions
 # Call `Run` when the application starts
 # Call `Shutdown` and then `Dispose` when the application stops.

{{{
    using(var bootstrapper = new DefaultBootstrapper<ICustomExtension>())
    {
        var strategy = new CustomStrategy();
        bootstrapper.Initialize(strategy);

        bootstrapper.AddExtension(new FirstCustomExtension());
        bootstrapper.AddExtension(...);
        bootstrapper.AddExtension(new NthCustomExtension());
        
        bootstrapper.Run();
		
        // When application finished call
		
        bootstrapper.Shutdown();
    }
}}}
_Note:`DefaultBootstrapper{TExtension}` and `AbstractStrategy{TExtension}` implement `IDisposable`. The bootstrapper takes care of disposing the strategy and the extensions if the correct behavior is attached. If you are using FxCop to check your compiled code it will produces warnings that you should dispose the strategy and the extensions which implement `IDisposable` before the references move out of scope. You can safely suppress these warnings._
= Advanced =
The bootstrapper can do more! Let us look into a more complex scenario. Often it is required to collect context information during the bootstrapping process and pass this information to the extension points. 

Imagine you are using an inversion of control container which intakes `IModule` implementations to register dependencies during the bootstrapping process. All `IModule` implementations need to be passed into the `IContainer` implementation upon construction. For backward compatibility the bootstrapper must automatically check whether an extension implements `IModuleProvider` and register the provided modules on the `IContainer` implementation. 

The application we are designing allocates both managed and unmanaged resources which need to be removed when the application is shutting down. To get this behavior some extension occasionally implement `IDisposable` which needs to be called when shutting down.

Furthermore the application uses configuration sections to be able to overwrite some default configurations without recompiling the application. These configuration entries must be parsed and passed to the extensions which rely on their existance.
== Extension interface ==
A custom extension interface for this example could look like the following:

{{{
    public interface ICustomExtension : IExtension
    {
        void Start();
        void ContainerInitializing(ICollection<IModule> modules);
        void ContainerInitialized(IContainer container);
        void Ready();
        void Stop();
    }
}}}
The extension interface above would indicate that the applications extension points are:
 * `Start`
 * `ContainerInitializing` which allows to add `IModule` implementations
 * `ContainerInitialized` which allows to resolve dependencies on the `IContainer`
 * `Ready`
 * `Stop`
 
An abstract base class for this use case:
{{{
    public abstract class ComplexExtensionBase : IComplexExtension
    {
        public string Name
        {
            get { return this.GetType().FullNameToString(); }
        }

        protected IContainer Container { get; private set; }

        public virtual void Start() { }
        public virtual void ContainerInitializing(ICollection<IModule> modules) { }

        public void ContainerInitialized(IContainer container)
        {
            this.Container = container;
	    this.ContainerInitializedCore(container);
        }

        public virtual void Ready() { }
        public virtual void Stop() { }
        public abstract string Describe();
	protected virtual void ContainerInitializedCore(IContainer container) { }
    }
}}}
This allows inheritors to override only the extension points that they are interested in.
 
The extension interface does not include:
 * the fact that the extensions must be checked whether they implement `IModuleProvider`
 * the fact that the extensions must be checked whether they implement `IDisposable`
 * the fact that configuration sections must be loaded for an extension if available
 
How can we extend the bootstrapping mechanism without modifying the custom extension interface? We need behaviors!
== Behaviors ==
{{{
    public class ModuleProvidingBehavior : IBehavior<ICustomExtension>
    {
        private readonly ICollection<IModule> modules;
		
        public FunqletProvidingBehavior(ICollection<IModule> modules)
        {
            this.modules = modules;
        }

        public string Name { get { return this.GetType().FullNameToString(); } }

        public void Behave(IEnumerable<ICustomExtension> extensions)
        {
            extensions.OfType<IModuleProvider>()
				.SelectMany(provider => provider, (provider, module) => module)
				.ToList()
				.ForEach(module => this.funqlets.Add(module));
        }

        public string Describe() { return "Collects all IModule's on extensions which implement IModuleProvider during bootstrapping."; }
    }
}}}

{{{
	public interface IModuleProvider : IEnumerable<IModule> { }
	
	public class CustomModule : IModule
    {
        public void Configure(IContainer container)
        {
			container.Register<DependencyUsingBehavior>().ToSelf();
            container.Register<IDependency>().To<Dependency>();
            container.Register<IBehavior<IComplexExtension>>().ToMethod(ctx => ctx.Resolve<DependencyUsingBehavior>());
        }
    }
	
	public class ExtensionWhichIsModuleProvider : CustomExtensionBase, IModuleProvider
    {
        public IEnumerator<IModule> GetEnumerator()
        {
            yield return new CustomModule();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }

        public override string Describe() { return "Extension which implements IModuleProvider"; }
    }
}}}

{{{
    public class DependencyUsingBehavior : IBehavior<ICustomExtension>
    {
        private readonly IDependency dependency;

        public DependencyUsingBehavior(IDependency dependency)
        {
            this.dependency = dependency;
        }

		public string Name { get { return this.GetType().FullNameToString(); } }

        public void Behave(IEnumerable<ICustomExtension> extensions)
        {
            this.dependency.Hello();
        }

        public string Describe() { "Uses IDependency and executes \"Hello()\" in the provided dependency."; }
    }
}}}

{{{
    public class DisposeExtensionBehavior : IBehavior<IExtension>
    {
		public string Name { get { return this.GetType().FullNameToString(); } }

        public void Behave(IEnumerable<IExtension> extensions)
        {
            foreach (IDisposable extension in extensions.OfType<IDisposable>())
            {
                extension.Dispose();
            }
        }

        public string Describe() { return "Disposes all extensions which implement IDisposable."; }
    }
}}}
== Strategy ==
A very basic strategy could look like the following:
{{{
    public class CustomStrategy : AbstractStrategy<ICustomExtension>
    {
        private readonly Collection<IModule> modules;
        private readonly Lazy<IContainer> container;

        public CustomStrategy()
        {
            this.modules = new Collection<IModule>();
            this.container = new Lazy<IContainer>(() => new Container());
        }

        protected override void DefineRunSyntax(ISyntaxBuilder<IComplexExtension> builder)
        {
            builder
                .Begin
                    .With(new ConfigurationSectionBehavior())
                    .With(new ExtensionConfigurationSectionBehavior())
                .Execute(e => e.Start())
                .Execute(() => this.modules, (e, ctx) => e.ContainerInitializing(ctx))
                    .With(mdls => new ModuleProvidingBehavior(mdls))
                .Execute(() => this.BuildContainer(), (e, ctx) => e.ContainerInitialized(ctx))
                    .With(ctx => ctx.Resolve<IBehavior<ICustomExtension>>())
                .Execute(e => e.Ready());
        }

        protected override void DefineShutdownSyntax(ISyntaxBuilder<IComplexExtension> builder)
        {
            builder
                .Execute(e => e.Stop())
                .End.With(new DisposeExtensionBehavior());
        }

        protected override void Dispose(bool disposing)
        {
            // Dispose the container
            base.Dispose(disposing);
        }

        private IContainer BuildContainer()
        {
            var lazyContainer = this.container.Value;
            foreach (IModule module in this.modules) {
                module.Load(lazyContainer);
            }
            return lazyContainer;
        }
    }
}}}

The strategy above would configure the applications startup and shutdown phase to:
 * During startup 
  * before calling any extension point load configuration sections
  * and then load extension configuration sections.
  * Call the extension point `Start` on all registered extensions
  * Initialize the context with `this.modules` and call the extension point `ContainerInitializing` with the context on all registered extensions
   * Execute the behavior `ModuleProvidingBehavior` which gains access to the context.
  * Initialize the context by calling `BuildContainer` and call the extension point `ContainerInitialized` with the context on all registered extensions
   * Execute the lazy resolved `IBehavior<ICustomExtension>`
  * Call the extension point `Ready` on all registered extensions
 * During shutdown 
  * call the extension point `Stop` on all registered extensions
  * dispose all extensions which implement `IDisposable`
== Syntax ==
The strategy above shows part of the fluent definition syntax the bootstrapper uses to gain knowledge about the startup and shutdown phase of the system. Here the Extended Backus-Naur-Form of the syntax:
{{{
Syntax = [ Begin ] { Execute } [ End ] .
Begin = { With } | End .
End = { EndWith } .
Execute = ExecuteAction | ExecuteActionOnExtension | ExecuteActionOnExtensionWithContext .
ExecuteAction = "Expression<Action>" { With | Execute | End } .
ExecuteActionOnExtension = "Expression<Action<TExtension>>" { With | Execute | End } .
ExecuteActionOnExtensionWithContext = "Expression<Func<TContext>>" "Expression<Action<TExtension, TContext>>" { WithOnContext | Execute | EndWithOnContext } .
With = Behavior | LazyBehavior { With | Execute | End } .
WithOnContext = LazyBehaviorWithContext { WithOnContext | Execute | EndWithOnContext } .
EndWith = Behavior | LazyBehavior { EndWith } .
EndWithOnContext = LazyBehaviorWithContext { EndWithOnContext } .
Behavior = "IBehavior<TExtension>" .
LazyBehavior = "Expression<Func<IBehavior<TExtension>>>" .
LazyBehaviorWithContext = "Expression<Func<TContext, IBehavior<TExtension>>>" .
}}}
[http://bbvcommon.googlecode.com/svn/wikiFiles/Bootstrapper/SyntaxEBNF.png]
_Note:TODO Check EBNF. The diagramm above is created with the amazing [http://code.google.com/p/ebnfvisualize/ ebnfvisualize]._
= Customization =
TODO