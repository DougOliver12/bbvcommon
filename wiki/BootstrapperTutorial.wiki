#summary Shows the basic usage of the Bootstrapper

= Introduction =
To get started with the bootstrapper you need the following three things:
 # Extension interface
 # Strategy
 # Bootstrapper setup
== Extension interface ==
The extension interface defines the extension points which are called by the bootstrapper. The custom extension interface must inherit from `IExtension` and can only declare methods which return `void` as extension points. A very basic extension interface could look like the following:

{{{
    public interface ICustomExtension : IExtension
    {
        void Start();
        void Stop();
    }
}}}
The extension interface above would indicate that the applications extension points are:
 * Start
 * Stop
That's basically it for the extension interface. Although we generally advice to build a base class which defines virtual members for the extension points. For example:

{{{
    public abstract class CustomExtensionBase : ICustomExtension
    {
        public string Name
        {
            get { return this.GetType().FullNameToString(); }
        }

        public virtual void Start() { }
        public virtual void Shutdown() { }
        public abstract string Describe();
    }
}}}
This allows inheritors to override only the extension points that they are interested in.

_Note: `IExtension` inherits from `IDescribable` which defines a name and a description. The name and the description are consumed by the reporting capability. The more expressive your names and descriptions are the more meaningful your report will be!_
== Strategy ==
The strategy defines the order of execution for extension points and behaviors. The custom strategy must inherit from `IStrategy`. For convenience there is a abstract base class `AbstractStrategy{TExtension}` which simplifies defining a custom strategy. A very basic strategy could look like the following:

{{{
    public class CustomStrategy : AbstractStrategy<ICustomExtension>
    {
        protected override void DefineRunSyntax(ISyntaxBuilder<ICustomExtension> builder)
        {
            builder.Execute(x => x.Start());
        }

        protected override void DefineShutdownSyntax(ISyntaxBuilder<ICustomExtension> builder)
        {
            builder.Execute(x => x.Stop());
        }
    }
}}}
The strategy above would configure the applications startup and shutdown phase to:
 * During startup call the extension point `Start` on all registered extensions
 * During shutdown call the extension point `Shutdown` on all registered extensions
Now let's look how the custom extension interface and the strategy get combined together in the bootstrapper.
== Bootstrapper setup ==
The bootstrapper setup is simply and straight forward. You can always follow the following steps:
 # Instantiate a new `DefaultBoostrapper<TExtension>`
 # Instantiate a new strategy
 # Initialize the bootstrapper with the strategy
 # Add the required extensions
 # Call `Run` when the application starts
 # Call `Shutdown` and then `Dispose` when the application stops.

{{{
	using(var bootstrapper = new DefaultBootstrapper<ICustomExtension>())
	{
		var strategy = new CustomStrategy();
		bootstrapper.Initialize(strategy);

		bootstrapper.AddExtension(new FirstCustomExtension());
		bootstrapper.AddExtension(...);
		bootstrapper.AddExtension(new NthCustomExtension());

		bootstrapper.Run();
		
		// When application finished call
		
		bootstrapper.Shutdown();
	}
}}}
_Note:`DefaultBootstrapper{TExtension}` and `AbstractStrategy{TExtension}` implement `IDisposable`. The bootstrapper takes care of disposing the strategy and the extensions if the correct behavior is attached. If you are using FxCop to check your compiled code it will produces warnings that you should dispose the strategy and the extensions which implement `IDisposable` before the references move out of scope. You can safely suppress these warnings._
= Customization =